% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\RequirePackage{amsmath,amssymb}
\PassOptionsToPackage{svgnames,dvipsnames,svgnames}{xcolor}
\documentclass{llncs}
%
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{mathpartir} % inference rules
\usepackage{extarrows}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xcolor}
\usepackage[bookmarks=true,colorlinks=true,allcolors=Green,breaklinks]{hyperref}
%\usepackage[pdfborder={0 0 0}]{hyperref}
%\usepackage[colorlinks=true,allcolors=Green,backref,pageanchor=true,plainpages=false, pdfpagelabels, bookmarks,bookmarksnumbered,
%pdfborder={0 0 0},  %removes outlines around hyper links in online display
%]{hyperref}

\input{macros}
%
\begin{document}

%
\frontmatter          % for the preliminaries

\mainmatter              % start of the contributions
%
\title{Hazelnut: A Minimal Bidirectionally Typed Structure Editor}
\subtitle{(Research Paper)}
%
%\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Cyrus Omar\inst{1}$^\dagger$ \and Michael Hilton\inst{2}$^\dagger$ \and
Ian Voysey\inst{1}$^\dagger$ \and \\Jonathan Aldrich\inst{1} \and Matthew A. Hammer\inst{3}}
%
\authorrunning{Omar et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%
\institute{Carnegie Mellon University
%\email{comar@cs.cmu.edu}\\
%\texttt{http://www.cs.cmu.edu/\homedir comar/}
\and
Oregon State University
%\email{hiltonm@eecs.oregonstate.edu}\\
\and
University of Colorado Boulder
%\email{Matthew.Hammer@colorado.edu}
\\
{}$^\dagger$~{Student Author}
}

\maketitle              % typeset the title of the contribution
\begin{abstract}
Programs are rich inductive structures, but  programmers typically construct and manipulate them only indirectly, through flat textual representations. This indirection  comes at a cost -- programmers must comprehend the various subtleties of textual syntax, and it can take several text editor actions to make a single syntactically and semantically well-defined change. %Manipulating ill-defined programs is difficult for programmers and complicates the design of programming tools.
During these sequences of editor actions, or when the programmer makes a mistake, programmers and programming tools must contend with malformed or semantically ill-defined program text, complicating the programming process.
%Unfortunately, this fact is somewhat obscure because  programmers typically construct and interact with  programs only indirectly, using a text editor composed with a parser.
%There are some benefits to this approach, to be sure, but the structural mismatch between programs and text  also imposes a cognitive burden.
%For example, the primitive edit actions available in a text editor (e.g. inserting or deleting a character or word)  do not always correspond to  sensible structural transformations.
%Indeed, most structural  transformations require performing many primitive edit actions.

\emph{Structure editors} promise to alleviate these burdens by exposing only edit actions that  produce sensible changes to the program structure.
Existing designs for structure editors, however, are complex and somewhat \emph{ad hoc}. They also focus mainly on syntactic well-formedness, so programs can still be left semantically ill-defined as they are being constructed.

In this paper, we report on our ongoing efforts to develop Hazelnut, a minimal  structure editor defined in the type-theoretic style that permits only syntactically and semantically sensible actions, without forcing the programmer to construct the program in a strictly ``top-down'' fashion.
Formally, Hazelnut is a bidirectionally typed lambda calculus extended with
1) \emph{holes} (which mark subterms that are under construction);
%, which are identified by variables tracked in a separate linear \emph{hole context}
2) a \emph{focus model}; and 3) a bidirectional \emph{action model} equipped with a useful \emph{action sensibility} theorem. %Programs with holes have a well-defined static semantics, and the action model is defined such that every performable action is both syntactically sensible (by construction) and semantically sensible (i.e. we can establish a useful \emph{action sensibility} theorem.)
%We conclude by outlining our vision of a full-scale programming system grown ``from the ground up'' around the same fundamental principles as Hazelnut.

%\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}
%
\input{intro.tex}

\section{Programming in Hazelnut}
\label{sec:example}
%
Figure~\ref{fig:first-example} gives an example of a Hazelnut user
programming the identity function over numbers, then applying this function
to an argument, the number literal $3$. 

The syntax is formally defined in Section \ref{sec:hazel}, but we will give the intuition here.
The example proceeds by tracing what happens to a term as different
actions are performed. The terms are shown in the first two columns of the
table: H-Expressions are terms that may have holes in them; Z-Expressions
are H-Expressions with a single subterm in focus. The third column names the action that is performed to the term in
focus in the Z-Expression to produce the next line. All lines change the Z-expression, but some lines (e.g. those corresponding to movement within the Z-expression) do not cause the corresponding H-expression to change.

%
Lines 1--9 consist of the user interactively constructing the identity
function. After the break, lines 10--15 consist of the user editing this
program so that it consists of a function application (of the first
program, bound to the variable $id$, not shown) to the literal argument $3$.

Line~1 begins with the simplest initial state: the H-Expression in question
is just the single hole and the Z-Expression is that single hole in focus,
indicated by the syntax~$\zwsel{\cdot}$. Focus determines where actions
transform the expressions.

The first action the user performs on the hole on focus is to fill it by
constructing a lambda abstraction. This results in the expressions on line
2, which have holes propagated for the body and type of the lambda. The
user then proceeds to move the focus between holes and fill them as
appropriate, resulting in the final expression on Line 9.

So far, this development is all largely type-driven. The user is trying to
write a function, and so follows the forms given by that structure. On line
10, the user decides to apply the lambda they've written to some
arguments. This is no longer the top-down type directed reasoning, but a
jump to a different task entirely.

We let $\textrm{id}$ be a metavarible standing for the expression
constructed at Line 9 and continue as the user chooses to construct an
application site. This creates the obligation to provide arguments, so the
user then constructs a literal value $3$. Intuitively we're now finished,
since the expression contains no further holes. Within the formalism,
though, we have to move to the outside of the expression before proceeding
with the finish action.

%% The third column~(\textbf{Next Action}) lists the first user action:
%% Constructing a lambda abstraction using variable~$x$.
%% %
%% The final column~(\textbf{Semantics}) indicates the semantic rule for this
%% action, Rule (\ref{r:conelamhole}), which gives general semantics for
%% introducing lambda terms into holes.
%% %
%% In Section~\ref{sec:hazel}, we list this rule, and the other rules used in
%% this final column. In total, these rules give a formal semantics to the
%% user actions, which relate each line's Z-Expression to the Z-Expression on
%% the subsequent line.

%% In addition to introducing the lambda term, and its variable, the
%% first user action~$\aConstruct{\flam{x}}$ also introduces a type
%% ascription for this function, as an arrow type, with holes for the
%% type of its domain and codomain.
%% %
%% The actions for Lines~2--5 consist of the user filling these holes
%% with the basetype $\tnum{}$.
%% %
%% To do so, the user constructs the type constructor twice (Lines 2 and
%% 4), and navigates between the holes with a move action (Line~3).
%% %
%% Generally, the move action~$\dNext$ moves the focus from one
%% sub-structure to the next sibling sub-structure of the (common) parent
%% structure; in this case, it moves from the domain type of the arrow
%% type to the codomain of the arrow type.
%% %

\begin{figure}[t]
\[
\begin{array}{|c||c|c||l|l|}
\hline
\# & \textbf{H-Expression} & \textbf{Z-Expression} & \textbf{Next Action} & \textbf{Semantics}
\\
\hline
1 &
\hhole{} &
\zwsel{\hhole{}}
&
\aConstruct{\flam{x}} & \refrule{\ref{r:conelamhole}}
\\ 2 &
\hlam{x}{\hhole{}} : \tarr{\hhole{}}{\hhole{}} &
\hlam{x}{\hhole{}} : \tarr{\zwsel{\hhole{}}}{\hhole{}}
&
\aConstruct{\fnum{}} & \refrule{\ref{r:contnum}}
\\ 3 &
\hlam{x}{\hhole{}} : \tarr{\tnum{}}{\hhole{}} &
\hlam{x}{\hhole{}} : \tarr{\zwsel{\tnum{}}}{\hhole{}}
&
\aMove{\dNext{}} & \refrule{\ref{r:movenextsib}}
\\ 4 &
&
\hlam{x}{\hhole{}} : \tarr{\tnum}{\zwsel{\hhole{}}}
&
\aConstruct{\fnum{}} & \refrule{\ref{r:contnum}}
\\ 5 &
\hlam{x}{\hhole{}} : \tarr{\tnum{}}{\tnum{}} &
\hlam{x}{\hhole{}} : \tarr{\tnum{}}{\zwsel{\tnum{}}}
&
\aMove{\dParent{}} & \refrule{\ref{r:moveparent}}
\\ 6 &
&
\hlam{x}{\hhole{}} : \zwsel{\tarr{\tnum{}}{\tnum{}}}
&
\aMove{\dPrev{}} & \refrule{\ref{r:moveprevsib}}
\\ 7 &
&
\zwsel{\hlam{x}{\hhole{}}} : \tarr{\tnum{}}{\tnum{}}
&
\aMove{\dChild{}} & \refrule{\ref{r:movefirstchild}}
\\ 8 &
&
\hlam{x}{\zwsel{\hhole{}}} : \tarr{\tnum{}}{\tnum{}}
&
\aConstruct{\fvar{x}} & \refrule{\ref{r:conevar}}
\\ 9 &
\hlam{x}{{x}} : \tarr{\tnum{}}{\tnum{}}
&
\hlam{x}{\zwsel{{x}}} : \tarr{\tnum{}}{\tnum{}}
&
\quad\textrm{---{}---}
&
\quad\textrm{---{}---}
\\
\hline
\hline
10 &
\hhole{\textrm{id}} : \tnum{} &
\hhole{\zwsel{{\textrm{id}}}} : \tnum{}
&
\aConstruct{\fap{}} & \refrule{\ref{r:coneapfn}}
\\
11 &
\hhole{\hap{{{\textrm{id}}}}{{\hhole{}}}} : \tnum{}
&
\hhole{\hap{{{\textrm{id}}}}{\zwsel{\hhole{}}}} : \tnum{}
&
\aConstruct{\fnumlit{3}} &  \refrule{\ref{r:conenumnum}}
\\
12 &
\hhole{\hap{{{\textrm{id}}}}{{\hnum{3}}}} : \tnum{}
&
\hhole{\hap{{{\textrm{id}}}}{\zwsel{\hnum{3}}}} : \tnum{}
&
\aMove{\dParent{}} &  \refrule{\ref{r:moveparent}}
\\
13 &
%\hhole{\hap{{{\textrm{id}}}}{{\hnum{3}}}} : \tnum{}
&
\hhole{\zwsel{\hap{{{\textrm{id}}}}{{\hnum{3}}}}} : \tnum{}
&
\aMove{\dParent{}} &  \refrule{\ref{r:moveparent}}
\\
14 &
%\hhole{\hap{{{\textrm{id}}}}{{\hnum{3}}}} : \tnum{}
&
\zwsel{\hhole{{\hap{{{\textrm{id}}}}{{\hnum{3}}}}}} : \tnum{}
&
\aMove{\dParent{}} &  \refrule{\ref{r:moveparent}}
\\
15 &
{\hap{{{\textrm{id}}}}{{\hnum{3}}}} : \tnum{}
&
\zwsel{{{\hap{{{\textrm{id}}}}{{\hnum{3}}}}}} : \tnum{}
&
\aFinish &  \refrule{\ref{r:finishana}}
\\
\hline

%% 11 &
%% {\textrm{id}} : \tarr{\tnum{}}{\tnum{}}
%% &
%% \hlam{x}{\zwsel{{x}}} : \tarr{\tnum{}}{\tnum{}}
%% &
%% \aMove{\dParent{}} & ?
%% \\ 12 &
%% %{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}
%% &
%% \zwsel{\hlam{x}{{{x}}}} : \tarr{\tnum{}}{\tnum{}}
%% &
%% \aMove{\dParent{}} & \refrule{15b} bad
%% \\ 13 &
%% %{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}
%% &
%% \zwsel{\hlam{x}{{{x}}} : \tarr{\tnum{}}{\tnum{}}}
%% &
%% \aConstruct{\fap{}} & \refrule{20h} bad
%% \\ 14 &
%% \hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{\hhole{}}
%% &
%% \hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{\zwsel{\hhole{}}}
%% &
%% \aConstruct{\fnumlit{3}} & \refrule{20l} bad
%% \\ 15 &
%% %\hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{\hhole{3}}
%% %&
%% %\hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{\zwsel{\hhole{3}}}
%% %&
%% %\aFinish{} & ?
%% %\\
%% \hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{{\hnum{3}}}
%% &
%% \hapP{{\textrm{id}} : \tarr{\tnum{}}{\tnum{}}}{\zwsel{{\hnum{3}}}}
%% &
%% \quad\textrm{---{}---}
%% &
%% \quad\textrm{---{}---}
%% \\
%% \hline
\end{array}
\]
\caption{Example of interactively constructing identity function in Hazelnut (Lines~1--10).
  Afterward, the user applies this function to an argument~(Lines 11--15).}
\label{fig:first-example}
\end{figure}

\section{Hazelnut}
\label{sec:hazel}
Hazelnut is based on the simply-typed lambda calculus extended with a single base type, $\tnum$. Its major constituents are:
\begin{itemize}
\item \textbf{H-types} and \textbf{H-expressions} (Sec. \ref{sec:holes}), which are terms with \emph{holes}. Holes mark subterms that are ``under construction.'' H-types classify H-expressions according to a {bidirectionally typed} static semantics.
\item \textbf{Z-types} and \textbf{Z-expressions} (Sec. \ref{sec:cursors}), which superimpose a single \emph{focus} onto H-types and H-expressions (using Huet's \emph{zipper pattern} \cite{JFP::Huet1997}.)
\item \textbf{Actions} (Sec. \ref{sec:actions}), which move the focus or modify the subterm in focus.

Whenever an action is performed on a well-typed expression, it produces another well-typed expression in a \emph{sensible} manner -- we define \emph{sensibility} in Sec. \ref{sec:actions}.
\end{itemize}

\subsection{Holes}\label{sec:holes}
\begin{figure}[t]
$\arraycolsep=4pt\begin{array}{lllllll}
\mathsf{HTyp} & \tau,\htau & ::= &
  \tarr{\htau}{\htau} ~\vert~
  \tnum ~\vert~
  \tehole\\
\mathsf{HExp} & e,\hexp & ::= &
  \hexp : \htau ~\vert~
  x ~\vert~
  \hlam{x}{\hexp} ~\vert~
  \hap{\hexp}{\hexp} ~\vert~
  \hnum{n} ~\vert~
  \hadd{\hexp}{\hexp} ~\vert~
  \hehole ~\vert~
  \hhole{\hexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of H-types and H-expressions. Metavariable $x$ ranges over variables and $n$ ranges over numerals.}
\label{fig:hexp-syntax}
\end{figure}

The syntax of H-types and H-expressions is given in Figure \ref{fig:hexp-syntax}. Most forms correspond directly to those of the simply-typed lambda calculus extended with type $\tnum$. The number expression corresponding to the number $n$ is drawn $\hnum{n}$, and for simplicity, we define only a single arithmetic operation, $\hadd{\hexp}{\hexp}$.

In addition to these standard forms, \emph{empty holes} are drawn $\hehole$ and \emph{non-empty H-expression holes} are drawn $\hhole{\hexp}$. Holes mark subterms that are, notionally, ``under construction.'' We will see what this formally corresponds to in a moment.

We refer to terms that do not contain subterms of hole form as \emph{complete}. Informally, we will use metavariables $\tau$ and $e$ rather than $\htau$ and $\hexp$ for complete H-types and H-expressions, respectively. Formally, we can derive $\hcomplete{\tau}$ when $\tau$ is a complete H-type, and $\hcomplete{e}$ when $e$ is a complete H-expression. We omit the straightforward definitions of these judgements for concision. The dynamics of Hazelnut, which we need not detail here, is defined only  over complete H-expressions (i.e. the user cannot ``run'' an incomplete program.)

The statics of Hazelnut is organized as a \emph{bidirectional type system} \cite{Pierce:2000:LTI:345099.345100}, i.e. around the following mutually defined typing judgements:
\[\arraycolsep=15pt\begin{array}{ll}
%\textbf{Judgement Form} & \textbf{Description}\\
\hsyn{\hGamma}{\hexp}{\htau} & \text{$\hexp$ synthesizes $\htau$}\\
\hana{\hGamma}{\hexp}{\htau} & \text{$\hexp$ analyzes against $\htau$}
\end{array}\]
where typing contexts, $\hGamma$, map the variables $x \in \domof{\hGamma}$ to hypotheses $x : \htau$.

Algorithmically, the type synthesis judgement specifies a function where the type is an output, and type analysis judgement specifies a function where the type is an input. This defines a \emph{local type inference} scheme. Moreover, making a judgemental distinction between synthesis and analysis is essential for giving a sensible action semantics to our system (Sec. \ref{sec:actions}.)

 %We use the metavariable $\Gamma$ for \emph{complete typing contexts}, i.e. typing contexts where each hypothesis mentions only complete types.


\begin{subequations}\label{rules:syn-ana}
Type synthesis is stronger than type analysis, i.e. if an expression is able to synthesize a type, it can also be analyzed against that type or any \emph{compatible} type. This is expressed by the following \emph{subsumption rule}:
\begin{equation}\label{rule:ana-subsume}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau'}\\
  \tcompat{\htau}{\htau'}
}{
  \hana{\hGamma}{\hexp}{\htau}
}
\end{equation}
The \emph{H-type compatibility} judgement, $\tcompat{\htau}{\htau'}$, reduces to syntactic equality for complete H-types. For incomplete H-types, the rules are given after we discuss the semantics of holes below.

First, let us reproduce the rules for the standard constructs. Type ascription allows the user to explicitly annotate an expression with the type that it is to be analyzed against:
\begin{equation}\label{rule:syn-asc}
\inferrule{
  \hana{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hexp : \htau}{\htau}
}
\end{equation}

A variable synthesizes the type that the context assigns to it:
\begin{equation}\label{rule:syn-var}
\inferrule{ }{
  \hsyn{\hGamma, x : \htau}{x}{\htau}
}
\end{equation}

Functions are not themselves annotated with types, so they can only appear in analytic position:
\begin{equation}\label{rule:syn-lam}
\inferrule{
  \hana{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\tarr{\htau_1}{\htau_2}}
}
\end{equation}

For function application, if the expression in function position synthesizes an arrow type, the argument is analyzed against the synthesized argument type:
\begin{equation}\label{rule:syn-ap}
\inferrule{
  \hsyn{\hGamma}{\hexp_1}{\tarr{\htau_2}{\htau}}\\
  \hana{\hGamma}{\hexp_2}{\htau_2}
}{
  \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\htau}
}
\end{equation}

Numbers synthesize type $\tnum$:
\begin{equation}\label{rule:syn-num}
\inferrule{ }{
  \hsyn{\hGamma}{\hnum{n}}{\tnum}
}
\end{equation}

Addition operates like a function over numbers:
\begin{equation}\label{rule:syn-plus}
\inferrule{
  \hana{\hGamma}{\hexp_1}{\tnum}\\
  \hana{\hGamma}{\hexp_2}{\tnum}
}{
  \hsyn{\hGamma}{\hadd{\hexp_1}{\hexp_2}}{\tnum}
}
\end{equation}

The rules given so far are sufficient to type complete H-expressions. The remaining rules give H-expressions with holes a well-defined static semantics.

The empty hole synthesizes the hole type:
\begin{equation}\label{rule:syn-ehole}
\inferrule{ }{
  \hsyn{\hGamma}{\hehole}{\tehole}
}
\end{equation}

A non-empty hole contains an H-expression that is ``under construction''. The inner expression must synthesize some type, but the non-empty hole synthesizes only the hole type:
\begin{equation}\label{rule:syn-hole}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hhole{\hexp}}{\tehole}
}
\end{equation}
The compatibility judgement $\tcompat{\htau}{\htau'}$, which appeared as a premise in the subsumption rule, makes the hole type compatible with any other type:
\begin{subequations}\label{rules:tcompat}
\begin{equation}\label{rule:tcompat-hole}
\inferrule{ }{
  \tcompat{\htau}{\tehole}
}
\end{equation}
Type compatibility is symmetric and reflexive:
\begin{equation}\label{rule:tcompat-comm}
\inferrule{
  \tcompat{\htau}{\htau'}
}{
  \tcompat{\htau'}{\htau}
}
\end{equation}
\begin{equation}\label{rule:tcompat-num}
\inferrule{ }{
  \tcompat{\tnum}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:tcompat-arr}
\inferrule{
  \tcompat{\htau_1}{\htau_1'}\\
  \tcompat{\htau_2}{\htau_2'}
}{
  \tcompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
}
\end{equation}
\end{subequations}
Consequently, by subsumption, we can derive that $\hana{\hGamma}{\hhole{\hnum{42}}}{\tarr{\tnum}{\tnum}}$. In other words, the user need not construct the program from the ``outside in''.

The final rule handles function applications where the expression in function position synthesizes a hole type, rather than an arrow type. We treat it as if it had instead synthesized $\tarr{\tehole}{\tehole}$:
\begin{equation}\label{rule:syn-ap-2}
\inferrule{
  \hsyn{\hGamma}{\hexp_1}{\tehole}\\
  \hana{\hGamma}{\hexp_2}{\tehole}
}{
  \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\tehole}
}
\end{equation}

The hole type behaves much like the type $?$ in prior work by Siek and Taha on gradual types for functional languages \cite{Siek06a}. Their system (which was not bidirectionally typed) also needed to define two rules for function application. In general, when a premise requires that a synthesized type be of a particular form, we need a special case where the synthesized hole type is treated instead as if it were the ``holey-est'' term of that form.\footnote{Alternatively, we might add a rule that allows expressions that synthesize hole type to then non-deterministically synthesize any other type, but maintaining determinism is useful in practice, so we avoid this approach.}

\end{subequations}
\subsection{Focus Model}\label{sec:cursors}
\begin{figure}
\hspace{-3px}$\arraycolsep=3pt\begin{array}{lllllll}
\mathsf{ZTyp} & \ztau & ::= &
  %\zlsel{\htau} ~\vert~
  \zwsel{\htau} ~\vert~
  %\zrsel{\htau} ~\vert~
  \tarr{\ztau}{\htau} ~\vert~
  \tarr{\htau}{\ztau} \\
\mathsf{ZExp} & \zexp & ::= &
  %\zlsel{\hexp} ~\vert~
  \zwsel{\hexp} ~\vert~
  %\zrsel{\hexp} ~\vert~
  \zexp : \htau ~\vert~
  \hexp : \ztau ~\vert~
  \hlam{x}{\zexp} ~\vert~
  \hap{\zexp}{\hexp} ~\vert~
  \hap{\hexp}{\zexp} ~\vert~
  \hadd{\zexp}{\hexp} ~\vert~
  \hadd{\hexp}{\zexp} ~\vert~
  \hhole{\zexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of Z-types and Z-expressions, i.e. types and expressions with holes and a single cursor.}
\label{fig:zexp-syntax}
\end{figure}

In order to identify a single subtree of an H-type or H-expression as the current focus of action, we apply Huet's \emph{zipper pattern} \cite{JFP::Huet1997}. The syntax of Z-types, $\ztau$, and Z-expressions, $\zexp$, is given in Figure \ref{fig:zexp-syntax}. The only base cases in these inductive grammars are $\zwsel{\htau}$ and $\zwsel{\hexp}$, which identify the H-type or H-expression that is the current focus. All other forms correspond to the recursive forms in the syntax of H-types and H-expressions, and contain exactly one ``hatted'' subterm that identifies the subtree where the focus will be found. All other sub-terms are H-types or H-expressions. Taken together, every syntactically well-formed Z-type and Z-expression contains exactly one focused H-type or H-expression.

We write $\removeSel{\ztau}$ for the H-type constructed by removing the focus marker from the Z-type $\ztau$. This straightforward metafunction is defined as follows:
\begin{align*}
%\removeSel{(\zlsel{\htau})} & = \htau\\
\removeSel{(\zwsel{\htau})} & = \htau\\
%\removeSel{(\zrsel{\htau})} & = \htau\\
\removeSel{(\tarr{\ztau}{\htau})} & = \tarr{\removeSel{\ztau}}{\htau}\\
\removeSel{(\tarr{\htau}{\ztau})} & = \tarr{\htau}{\removeSel{\ztau}}
\end{align*}

Similarly, we write $\removeSel{\zexp}$ for the H-expression constructed by removing the focus marker from the Z-expression $\zexp$:
\begin{align*}
%\removeSel{(\zlsel{\hexp})} & = \hexp\\
\removeSel{(\zwsel{\hexp})} & = \hexp\\
%\removeSel{(\zrsel{\hexp})} & = \hexp\\
\removeSel{(\zexp : \htau)} & = \removeSel{\zexp} : \htau\\
\removeSel{(\hexp : \ztau)} & = \hexp : \removeSel{\ztau}\\
\removeSel{(\hlam{x}{\zexp})} & = \hlam{x}{\removeSel{\zexp}}\\
\removeSel{(\hap{\zexp}{\hexp})} & = \hap{\removeSel{\zexp}}{\hexp}\\
\removeSel{(\hap{\hexp}{\zexp})} & = \hap{\hexp}{\removeSel{\zexp}}\\
\removeSel{(\hadd{\zexp}{\hexp})} & = \hadd{\removeSel{\zexp}}{\hexp}\\
\removeSel{(\hadd{\hexp}{\zexp})} & = \hadd{\hexp}{\removeSel{\zexp}}\\
\removeSel{\hhole{\zexp}} &= \hhole{\removeSel{\zexp}}
\end{align*}

\subsection{Action Semantics}\label{sec:actions}
\begin{figure}[t]
\hspace{-3px}$\arraycolsep=3pt\begin{array}{llcllll}
\mathsf{Action} & \alpha & ::= &
  \aMove{\delta} ~\vert~
  %\aSelect{\delta} ~\vert~
  \aDel ~\vert~
  %\aReplace{\htau} ~\vert~
  %\aReplace{\hexp} ~\vert~
  \aConstruct{\varphi} ~\vert~
  \aFinish\\
\mathsf{Direction} & \delta & ::= &
  \dChild ~\vert~
  \dParent ~\vert~
  \dNext ~\vert~
  \dPrev\\
\mathsf{Form} & \varphi & ::= &
  \farr ~\vert~
  \fnum \\
& & \vert &
  \fasc ~\vert~
  \fvar{x} ~\vert~
  \flam{x} ~\vert~
  \fap ~\vert~
  \farg ~\vert~
  \fnumlit{n} ~\vert~
  \fplus
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of actions.}
\label{fig:action-syntax}
\end{figure}

The syntax of \emph{actions}, $\alpha$, is given in Figure \ref{fig:action-syntax}. The \emph{action semantics} of Hazelnut is organized around three judgements:
\[\arraycolsep=10pt\begin{array}{ll}
%\textbf{Judgement Form} & \textbf{Description}\\
\performTyp{\ztau}{\alpha}{\ztau'} & \text{Performing $\alpha$ on $\ztau$ produces $\ztau'$}\\
\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'} & \text{Performing $\alpha$ on $\zexp$ when $\removeSel{\zexp}$ synthesizes type $\htau$}\\
& \text{produces $\zexp'$ such that $\removeSel{\zexp'}$ synthesizes type $\htau'$}\\
\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'} & \text{Performing $\alpha$ on $\zexp$ when analyzing $\removeSel{\zexp}$ against $\htau$}\\
& \text{produces $\zexp'$, such that $\removeSel{\zexp'}$ can also be analyzed}\\
& \text{against $\htau$}
\end{array}\]

As suggested by the descriptions of the judgements above, our action semantics maintains the following \emph{action sensibility} theorem:
\begin{theorem}[Action Sensibility] Both of the following hold:
\label{thrm:actsafe}
\begin{enumerate}
\item If $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ then $\hsyn{\hGamma}{\removeSel{\zexp'}}{\htau'}$.
\item If $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ and $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ then $\hana{\hGamma}{\removeSel{\zexp'}}{\htau}$.
\end{enumerate}
\end{theorem}

In other words, every action leaves the program in a semantically well-defined state. More specifically, actions performed on expressions that synthesize a type can only produce expressions that also synthesize some (possibly different) type. Actions performed on expressions in analytic position (e.g. those under type ascriptions or in argument position) can only produce expressions that can be analyzed against the type provided. As such, Hazelnut enforces the natural type discipline described informally in the introduction. As we will see, non-empty holes allow us to maintain a slightly more flexible discipline, i.e. one where the programmer is not forced to construct the program from the outside-in but rather can construct fragments of the program inside a hole until ready to ``expose'' them to the surrounding program.

The action semantics includes a subsumption rule much like the one for underlying semantics of H-expressions:
\begin{equation}
  \inferrule{
    \performSyn{\hGamma}{\zexp}{\htau'}{\alpha}{\zexp'}{\htau''}\\
    \tcompat{\htau}{\htau''}
  }{
    \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}
  }
\end{equation}


We will also need to define type incompatibility, $\tincompat{\htau}{\htau'}$, as follows:
\begin{subequations}
  \begin{equation}
    \inferrule{
      \tincompat{\htau}{\htau'}
    }{
      \tincompat{\htau'}{\htau}
    }
  \end{equation}
  \begin{equation}
    \inferrule{ }{
      \tincompat{\tnum}{\tarr{\htau_1}{\htau_2}}
    }
  \end{equation}
  \begin{equation}
    \inferrule{
      \tincompat{\htau_1}{\htau_1'}
    }{
      \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
    }
  \end{equation}
  \begin{equation}
    \inferrule{
      \tincompat{\htau_2}{\htau_2'}
    }{
      \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
    }
  \end{equation}
\end{subequations}


\subsubsection{Relative Movement} Movement actions change the focus but do not change the underlying H-type or H-expression (so action sensibility is easy to show.)

The rules for relative movement within Z-types are given below and should be fairly self-explanatory:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }{
      \aMove{\dChild}
    }{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \tarr{{\htau_1}}{\zwsel{\htau_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \tarr{\zwsel{\htau_1}}{{\htau_2}}
    }{
      \aMove{\dNext}
    }{
      {\tarr{\htau_1}{\zwsel{\htau_2}}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \tarr{{\htau_1}}{\zwsel{\htau_2}}
    }{
      \aMove{\dPrev}
    }{
      {\tarr{\zwsel{\htau_1}}{{\htau_2}}}
    }
  }
\end{equation}
\begin{equation}
\inferrule{
  \performTyp{
    \ztau
  }{
    \aMove{\delta}
  }{
    \ztau'
  }
}{
  \performTyp{
    \tarr{\ztau}{\htau}
  }{
    \aMove{\delta}
  }{
    \tarr{\ztau'}{\htau}
  }
}
\end{equation}
\begin{equation}
  \inferrule{
    \performTyp{
      \ztau
    }{
      \aMove{\delta}
    }{
      \ztau'
    }
  }{
    \performTyp{
      \tarr{\htau}{\ztau}
    }{
      \aMove{\delta}
    }{
      \tarr{\htau}{\ztau}
    }
  }
\end{equation}
\end{subequations}
The final two rules above recurse into the zipper structure.

The rules for relative movement within Z-expressions are similar. Movement is type-independent, so we defer to an auxiliary judgement:
\begin{subequations}
\begin{equation}
\inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performSyn{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}{\htau}
}
\end{equation}
\begin{equation}
\inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performAna{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}
}
\end{equation}
\end{subequations}
For concision, we show only the rules for the ascription forms:
\begin{subequations}
  \begin{equation}
    \label{r:movefirstchild}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp : \htau}
    }{
      \aMove{\dChild}
    }{
      \zwsel{\hexp} : \htau
    }
  }
\end{equation}
\begin{equation}
  \label{r:moveparent}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp} : \htau
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \hexp : \zwsel{\htau}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}
\begin{equation}
  \label{r:movenextsib}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp} : \htau
    }{
      \aMove{\dNext}
    }{
      \hexp : \zwsel{\htau}
    }
  }
\end{equation}
\begin{equation}
  \label{r:moveprevsib}
  \inferrule{ }{
    \performTyp{
      \hexp : \zwsel{\htau}
    }{
      \aMove{\dPrev}
    }{
      \zwsel{\hexp} : \htau
    }
  }
\end{equation}
\begin{equation}
\inferrule{
  \performTyp{
    \zexp
  }{
    \aMove{\delta}
  }{
    \zexp'
  }
}{
  \performTyp{
    \zexp : \htau
  }{
    \aMove{\delta}
  }{
    \zexp' : \htau
  }
}
\end{equation}
\begin{equation}
  \inferrule{
    \performTyp{
      \ztau
    }{
      \aMove{\delta}
    }{
      \ztau'
    }
  }{
    \performTyp{
      \hexp : \ztau
    }{
      \aMove{\delta}
    }{
      \hexp : \ztau'
    }
  }
\end{equation}
\end{subequations}
\subsubsection{Deletion}
Types:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aDel
    }{
      \zwsel{\tehole}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performTyp{\ztau}{\aDel}{\ztau'}
  }{
    \performTyp{\tarr{\ztau}{\htau}}{\aDel}{\tarr{\ztau'}{\htau}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performTyp{\ztau}{\aDel}{\ztau'}
  }{
    \performTyp{\tarr{\htau}{\ztau}}{\aDel}{\tarr{\htau}{\ztau'}}
  }
\end{equation}
\end{subequations}

Expressions also not type-dependent, so define auxiliary judgement:
\begin{subequations}
\begin{equation}
  \inferrule{
    \performDel{\zexp}{\zexp'}
  }{
    \performSyn{\hGamma}{\zexp}{\htau}{\aDel}{\zexp'}{\htau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performDel{\zexp}{\zexp'}
  }{
    \performAna{\hGamma}{\zexp}{\htau}{\aDel}{\zexp'}
  }
\end{equation}
\end{subequations}
Base case turns into a hole:
\begin{subequations}
\begin{equation}
\inferrule{ }{
  \performDel{\zwsel{\hexp}}{\hehole}
}
\end{equation}
Rule for ascription forms:
\begin{equation}
  \inferrule{
    \performDel{\zexp}{\zexp'}
  }{
    \performDel{\zexp : \htau}{\zexp' : \htau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performTyp{\ztau}{\aDel}{\ztau'}
  }{
    \performDel{\hexp : \ztau}{\hexp : \ztau'}
  }
\end{equation}
If you delete the inside of a hole, it becomes the empty hole:
\begin{equation}
  \inferrule{ }{
    \performDel{\hhole{\zwsel{\hexp}}}{\hehole}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \zexp \neq \zwsel{\hexp}\\
    \performDel{\zexp}{\zexp'}
  }{
    \performDel{\hhole{\zexp}}{\hhole{\zexp'}}
  }
\end{equation}
\end{subequations}
\subsubsection{Construction} Types:
\begin{subequations}
  \begin{equation}
    \label{r:contarr}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aConstruct{\farr}
    }{
      \tarr{\htau}{\zwsel{\tehole}}
    }
  }
\end{equation}
  \begin{equation}
    \label{r:contnum}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tehole}
    }{
      \aConstruct{\fnum}
    }{
      \zwsel{\tnum}
    }
  }
\end{equation}
  \begin{equation}
    \label{r:contarrL}
  \inferrule{
    \performTyp{\ztau}{\aConstruct{\varphi}}{\ztau'}
  }{
    \performTyp{
      \tarr{\ztau}{\htau}
    }{
      \aConstruct{\varphi}
    }{
      \tarr{\ztau'}{\htau}
    }
  }
\end{equation}
  \begin{equation}
    \label{r:contarrR}
  \inferrule{
    \performTyp{\ztau}{\aConstruct{\varphi}}{\ztau'}
  }{
    \performTyp{
      \tarr{\htau}{\ztau}
    }{
      \aConstruct{\varphi}
    }{
      \tarr{\htau}{\ztau'}
    }
  }
\end{equation}
\end{subequations}

Expressions:
\begin{subequations}

Ascription:
\begin{equation}
  \inferrule{ }{
    \performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\zwsel{\hexp : \htau}}{\htau}
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\zwsel{\hexp : \htau}}
  }
\end{equation}

variables:
\begin{equation}
  \label{r:conevar}
  \inferrule{ }{
    \performSyn{\hGamma, x : \htau}{\zwsel{\hehole}}{\tehole}{\aConstruct{\fvar{x}}}{\zwsel{x}}{\htau}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\htau'}
  }{
    \performAna{\hGamma, x : \htau'}{\zwsel{\hehole}}{\htau}{\aConstruct{\fvar{x}}}{\hhole{\zwsel{x}}}
  }
\end{equation}

lambda:
\begin{equation}
  \label{r:conelamhole}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\aConstruct{\flam{x}}}
      {\hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}}
      {\tarr{\tehole}{\tehole}}
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\tarr{\htau_1}{\htau_2}}
      {\aConstruct{\flam{x}}}
      {\hlam{x}{\zwsel{\hehole}}}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\flam{x}}}
      {\hhole{
        \hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}
      }}
  }
\end{equation}

application:
\begin{equation}
  \label{r:coneapfn}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\tarr{\htau_1}{\htau_2}}
      {\aConstruct{\fap}}
      {\hap{\hexp}{\zwsel{\hehole}}}
      {\htau_2}
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\tehole}
      {\aConstruct{\fap}}
      {\hap{\hexp}{\zwsel{\hehole}}}
      {\tehole}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fap}}
      {\hap{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tehole}
  }
\end{equation}

argument:
\begin{equation}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\farg}}
      {\hap{\zwsel{\hehole}}{\hexp}}
      {\tehole}
  }
\end{equation}

number:
\begin{equation}
  \label{r:conenumnum}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\aConstruct{\fnumlit{n}}}
      {\zwsel{\hnum{n}}}
      {\tnum}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\fnumlit{n}}}
      {\hhole{\zwsel{\hnum{n}}}}
  }
\end{equation}

plus:
\begin{equation}
  \inferrule{
    \tcompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hexp}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}
\end{subequations}

\subsubsection{Finish Hole}

\begin{subequations}
  \begin{equation}
    \label{r:finishana}
  \inferrule{
    \hsyn{\hGamma}{\hexp}{\htau'}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\tehole}
      {\aFinish}
      {\zwsel{\hexp}}
      {\htau'}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \hana{\hGamma}{\hexp}{\htau}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\htau}
      {\aFinish}
      {\zwsel{\hexp}}
  }
\end{equation}
\end{subequations}
\subsection{Metatheory}\label{sec:mt}

\begin{theorem}[Action Determinism] All of the following hold:
\label{thrm:actdet}
\begin{enumerate}
\item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}{\htau''}$ then $\zexp' = \zexp''$ and $\htau' = \htau''$.
\item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and $\tcompat{\htau}{\htau'}$ and $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ or $\performAna{\hGamma}{\zexp}{\htau'}{\alpha}{\zexp''}$ then $\zexp' = \zexp''$.
\item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ and $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ then $\zexp' = \zexp''$.
\end{enumerate}
\end{theorem}


\subsubsection{Mechanization}
\label{sec:mech}
\input{agda.tex}

\section{Implementation}
\label{sec:impl}

\subsection{Implementation Concepts}

\begin{figure}
\centering
\includegraphics[width=4in]{Implementation_Diagram}
\caption{Implementation Concepts. Each Action,Zipper Structure, View combination is considered to be ``instantaneous''}
\label{fig:FRP}
\end{figure}

The key insight of our implementation strategy is in how to interpret the input from the user.
In a traditional editor, the input from the user is a stream of characters, and there are no guarantees that at any point the program is syntactically correct.
In contrast, in a structured editor, the input from the user is a stream of operations.  These operations can be considered atomic, and will always leave the program in a syntactically correct state.
This insight leads us to conclude that a natural way to implement this editor would be using Functional Reactive Programming~\cite{Wan:2000:FRP:349299.349331} (FRP).
Figure~\ref{fig:FRP} illustrates the concept of an FRP structured editor.
The input from the user is a stream of actions.  Each action results in a change to the underlying model (i.e., a new Zipper Structure object is created after each input action from the user.
Each model change results in an updated view which is then presented to the user.  The user can then consider this new view when they choose a new action as input.

\subsection{HZ}
We explore the concepts presented in the paper in HZ, our current implementation.
In order to reach the widest possible audience, we decided to implement HZ as a web application.
In order to take advantage of all the benefits of FRP, we chose to implement HZ using OCaml\footnote{https://ocaml.org/}, Js\_of\_ocaml\footnote{http://ocsigen.org/js\_of\_ocaml/} and React\footnote{http://erratique.ch/software/react}.
Our code as well as directions for how to run and compile can be found here: \url{https://github.com/MichaelHilton/impl-tfp16}
At the time of submission, HZ should very much be considered a work in progress.

\section{Related Work}\label{sec:rw}
\subsection{Structure Editors}

Structured editing as a way to eliminate the possibility of syntax errors has a long history.  An early example is the
The Cornell Program Synthesizer~\cite{teitelbaum_cornell_1981}, first published in 1981.
The synthesizer generator~\cite{Reps:1984:SG:390010.808247} allows the user to create an attribute-grammar specification that then can be used to edit documents in a structured way.
CENTAUR~\cite{Borras:1988:CS:64140.65005} produces a language specific environment from a user defined formal specification of a language.  However, none of the approaches include Holes or Zippers.


A common application for structure editors has been for educational uses.
GNOME\cite{garlan_gnome:_1984} was developed to teach programming to undergraduates.
Scratch~\cite{Resnick:2009:SP:1592761.1592779} is a structure editor targeted at children ages 8 to 16.
Touchedevelop \cite{tillmann_touchdevelop:_2011} Incorporates a structure editor for enabling development on touch devices, and is used to teach highschool students.
Alice~\cite{Conway:2000:ALL:332040.332481} is a 3-D programming language with structure editor for teaching novice CS undergraduate students.
In contrast with these, Hazelnut is not developed specifically for the purpose computer science education.

Not all structure editors are for educational purposes though.
mbeddr. \cite{voelter_mbeddr:_2012} is an extensible C-based Programming Language and IDE for embedded systems.
mbeddr is build on top of the JetBrains MPS framework.
Another popular approach is to bring elements of structured editing into a traditional editor.
Codelets \cite{oney_codelets:_2012} uses structured editing to add interactive documentation and examples in an editor.
Barista\cite{ko_barista:_2006} allows creating of user interfaces in Java using structured editing.
Active code completion~\cite{Omar:2012:ACC:2337223.2337324} allows developers to introduce structured editing interfaces called  \emph{palettes} into their editor.
These solutions all represent an incremental change from existing technologies.  However, in this paper we present a theoretical model for designing a type-theoretic structure editor from the ground up.

Lamdu~\cite{lamdu} is both an editor and a language. The language is similar to Haskell, and the editor uses structure editing to enable Live Programming, where the code is always being executed as it is being written.
While Lamdu has many great features, there is no theoretical basis presented for their work.







%Drag-and-drop / for novices: lots of examples, e.g. Alice and others
%
%Contemporary: Lamdu, MPS/Mbeddr, TouchDevelop
%
%Hybrid: Cyrus' active code completion paper

%\subsection{Refactoring Models}
%(Michael, can you fill this section out?)

%\subsection{Formal Editor Models}
%Need to do a search to see what else has been done...

\section{Discussion \& Conclusion}
\label{sec:future}
\subsection{Future Work}
\begin{itemize}
\item More powerful language (codesigned and mechanized as we go along -- having a powerful editor might allow us to dispense with certain complex language features; give example of ad hoc polymorphism?)
\item Keyboard chords
\item Formal action suggestion and ranking models
\item Type-Specific Projections (ala TSLs)
\item Typed Documents
\item Collaboration (packaging system, diff algorithm, multiple cursors, etc.)
\item Connection between our notion of focus in 2.2 and focusing in proof theory
\item Investigate an equational theory of holes: $\hhole{\hhole{e}}$ should
  mean the same thing as $\hhole{e}$, for example
\end{itemize}

This work provides a foundation for studying all of these concepts independently -- show how they work with this system and it should be straightforward to scale to bigger system.

\begin{quote}
In any case, these are but steps toward more graphical program-description systems, for we will not forever stay confined to mere strings of symbols.

--- Minsky, Turing Award lecture
\end{quote}

%
% ---- Bibliography ----
%
% TODO
%\begin{thebibliography}{5}
\bibliographystyle{abbrv}
\bibliography{bibliography}
\end{document}
